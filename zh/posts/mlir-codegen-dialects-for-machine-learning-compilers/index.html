<!DOCTYPE html>
<html lang='zh' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>机器学习编译器代码生成相关 MLIR Dialect | Lei.Chat()</title>

<meta name="generator" content="Hugo Eureka 0.8.4" />
<link rel="stylesheet" href="https://www.lei.chat/css/eureka.min.css">
<script defer src="https://www.lei.chat/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/bash.min.js"
     crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/c.min.js"
     crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/cmake.min.js"
     crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/cpp.min.js"
     crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/glsl.min.js"
     crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/javascript.min.js"
     crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/llvm.min.js"
     crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/python.min.js"
     crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/shell.min.js"
     crossorigin></script>

<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js" 
  integrity="sha256-Zmpaaj&#43;GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE="  crossorigin></script>
<link rel="preconnect" href="https://www.google-analytics.com" crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-109525036-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-109525036-1');
</script>


<link rel="icon" type="image/png" sizes="32x32" href="https://www.lei.chat/images/avatar_hudaf23b5d8d39c4f2b01519ceec7d6b7b_105358_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://www.lei.chat/images/avatar_hudaf23b5d8d39c4f2b01519ceec7d6b7b_105358_180x180_fill_box_center_3.png">

<meta name="description"
  content="在这个系列的首篇文章中我分享了对编译器和中间表示 (IR) 演进趋势的整体理解，
也讨论了 LLVM IR, SPIR-V, 和 MLIR 所要解决的问题以及相应的设计着眼点。
今天对 MLIR 做进一步展开，分析一下机器学习相关的 dialect 体系。">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Posts",
      "item":"https://www.lei.chat/zh/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"机器学习编译器代码生成相关 MLIR Dialect",
      "item":"https://www.lei.chat/zh/posts/mlir-codegen-dialects-for-machine-learning-compilers/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.lei.chat/zh/posts/mlir-codegen-dialects-for-machine-learning-compilers/"
    },
    "headline": "机器学习编译器代码生成相关 MLIR Dialect | Lei.Chat()",
    "image": "https://www.lei.chat/posts/mlir-codegen-dialects-for-machine-learning-compilers/codegen-dialect-hierarchy.svg",
    "datePublished": "2022-02-20T15:21:03-05:00",
    "dateModified": "2022-02-20T15:21:03-05:00",
    "wordCount":  6688 ,
    "publisher": {
        "@type": "Person",
        "name": "Lei Zhang",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.lei.chat/images/avatar.png"
        }
        },
    "description": "\u003cp\u003e在\u003ca href=\u0022..\/compilers-and-irs-llvm-ir-spirv-and-mlir\/\u0022\u003e这个系列的首篇文章\u003c\/a\u003e中我分享了对编译器和中间表示 (IR) 演进趋势的整体理解，\n也讨论了 \u003ca href=\u0022..\/compilers-and-irs-llvm-ir-spirv-and-mlir\/#llvm-ir\u0022\u003eLLVM IR\u003c\/a\u003e, \u003ca href=\u0022..\/compilers-and-irs-llvm-ir-spirv-and-mlir\/#spir-v\u0022\u003eSPIR-V\u003c\/a\u003e, 和 \u003ca href=\u0022..\/compilers-and-irs-llvm-ir-spirv-and-mlir\/#mlir\u0022\u003eMLIR\u003c\/a\u003e 所要解决的问题以及相应的设计着眼点。\n今天对 MLIR 做进一步展开，分析一下机器学习相关的 dialect 体系。\u003c\/p\u003e"
}
</script><meta property="og:title" content="机器学习编译器代码生成相关 MLIR Dialect | Lei.Chat()" />
<meta property="og:type" content="article" />


<meta property="og:image" content="https://www.lei.chat/images/avatar.png">


<meta property="og:url" content="https://www.lei.chat/zh/posts/mlir-codegen-dialects-for-machine-learning-compilers/" />




<meta property="og:description" content="在这个系列的首篇文章中我分享了对编译器和中间表示 (IR) 演进趋势的整体理解，
也讨论了 LLVM IR, SPIR-V, 和 MLIR 所要解决的问题以及相应的设计着眼点。
今天对 MLIR 做进一步展开，分析一下机器学习相关的 dialect 体系。" />




<meta property="og:locale" content="zh" />



<meta property="og:locale:alternate" content="en" />




<meta property="og:site_name" content="Lei.Chat()" />






<meta property="article:published_time" content="2022-02-20T15:21:03-05:00" />


<meta property="article:modified_time" content="2022-02-20T15:21:03-05:00" />



<meta property="article:section" content="posts" />


<meta property="article:tag" content="mlir" />

<meta property="article:tag" content="代码生成" />

<meta property="article:tag" content="dialect" />

<meta property="article:tag" content="机器学习" />

<meta property="article:tag" content="编译器" />

<meta property="article:tag" content="tf" />









<meta property="og:see_also" content="https://www.lei.chat/zh/posts/mlir-linalg-dialect-and-patterns/" />



<meta property="og:see_also" content="https://www.lei.chat/zh/posts/mlir-vector-dialect-and-patterns/" />





<meta property="og:see_also" content="https://www.lei.chat/zh/posts/compilers-and-irs-llvm-ir-spirv-and-mlir/" />






<body class="flex flex-col min-h-screen">
  <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
    <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/zh/" class="mr-6 text-primary-text text-xl font-bold">Lei.Chat()</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/zh/posts/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  mr-4">文章</a>
            <a href="/zh/tags/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">标签</a>
            <a href="/zh/categories/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">主题</a>
            <a href="/zh/series/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">系列</a>
            <a href="/zh/authors/me" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">关于</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
            <div class="relative pt-4 pl-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="languageMode">
                    <i class="fas fa-globe"></i>
                    <span class="pl-1">简体中文</span>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open-lang">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='languageOptions'>
                    <a class="px-4 py-1 hover:text-eureka" href="https://www.lei.chat/zh/posts/mlir-codegen-dialects-for-machine-learning-compilers/">简体中文</a>
                    <a class="px-4 py-1 hover:text-eureka" href="https://www.lei.chat/posts/mlir-codegen-dialects-for-machine-learning-compilers/">English</a>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
        switchLanguage()
    });
</script>
</div>
  </header>
  <main class="flex-grow pt-16">
    <div class="pl-scrollbar">
      <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
    <div
        class="col-span-2  lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
        <h1 class="font-bold text-3xl text-primary-text">机器学习编译器代码生成相关 MLIR Dialect</h1>
        <div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
    <div class="mr-6 my-2">
        <i class="fas fa-calendar mr-1"></i>
        <span>2022-02-20</span>
    </div>
    <div class="mr-6 my-2">
        <i class="fas fa-clock mr-1"></i>
        <span>14分钟阅读时长</span>
    </div>
    
    
    
    <div class="mr-6 my-2">
        <i class="fas fa-folder mr-1"></i>
        
        <a href="https://www.lei.chat/zh/categories/%E7%BC%96%E8%AF%91%E5%99%A8/" class="hover:text-eureka">编译器</a><span>, </span>
        
        
        <a href="https://www.lei.chat/zh/categories/ir/" class="hover:text-eureka">ir</a><span>, </span>
        
        
        <a href="https://www.lei.chat/zh/categories/mlir/" class="hover:text-eureka">mlir</a><span>, </span>
        
        
        <a href="https://www.lei.chat/zh/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8E%A8%E7%90%86/" class="hover:text-eureka">机器学习推理</a>
        
    </div>
    

    
    <div class="mr-6 my-2">
        <i class="fas fa-th-list mr-1"></i>
        
        <a href="https://www.lei.chat/zh/series/%E7%BC%96%E8%AF%91%E5%99%A8%E5%BC%80%E5%8F%91/" class="hover:text-eureka">编译器开发</a>
        
    </div>
    
</div>

        
        <div class="content">
            <p>在<a href="../compilers-and-irs-llvm-ir-spirv-and-mlir/">这个系列的首篇文章</a>中我分享了对编译器和中间表示 (IR) 演进趋势的整体理解，
也讨论了 <a href="../compilers-and-irs-llvm-ir-spirv-and-mlir/#llvm-ir">LLVM IR</a>, <a href="../compilers-and-irs-llvm-ir-spirv-and-mlir/#spir-v">SPIR-V</a>, 和 <a href="../compilers-and-irs-llvm-ir-spirv-and-mlir/#mlir">MLIR</a> 所要解决的问题以及相应的设计着眼点。
今天对 MLIR 做进一步展开，分析一下机器学习相关的 dialect 体系。</p>
<p>值得注意的是，MLIR 是一个编译器基础设施，它可以用来编写各种领域专用编译器，并不限于机器学习。
不过机器学习确实是 MLIR 得到最活跃开发和应用的领域，尤其是用来转换各种 ML 模型，以及支持各种异构硬件。</p>
<h2 id="基础组件">基础组件</h2>
<p>编译器的一大优势是<strong>可组合性 (composability)</strong>。
如果功能甲、乙、丙分别得到了实现，那么它们的各种组合也自然而然会得到支持。
这种特性是编译器与算子库 (library) 的核心区别之一；在算子库中，不同的组合可能需要经由完全不同的手写代码来实现。
通过把指数级问题变成线性问题，编译器长期而言可以缩减大量的工程投入。</p>
<p>为实现这种可组合性，我们需要<strong>分解问题而后开发适宜的基础组件 (building block)</strong>。
在中间表示中， 我们一般把这些基础组件定义成各种操作 (operation)。
但对机器学习而言，仅用操作是很难组织出结构清晰优美的软件栈的，
因为输入模型和生成代码之间存在着巨大的语义鸿沟 (semantic gap)。除此之外，输入模型和目标硬件也种类繁多，有着各式各样的需求。
为此，MLIR 通过 dialect 机制实现了更高层次的基础组件。</p>
<p>一个 dialect 基本可以理解为一个命名空间。
在这个命名空间中，我们可以定义一系列互补协作的操作，和这些操作所需的类型 (type) 以及属性 (attribute) 等等。
特定的机器学习编译器只需要组合现有的 dialect，并加以自己的扩展或者定制。
这当中，MLIR dialect 有几个特性值得一提&mdash;</p>
<h3 id="内嵌结构的操作">内嵌结构的操作</h3>
<p>操作无论对表示还是转换而言，都是编译器中的原子性组件。
我们可以把操作放到基础块 (basic block) 中，然后把基础块放到函数 (function) 中。
但这只是浅浅的两层结构；语义 (semantic) 其实还是依赖于每个单独的操作，模式匹配 (pattern matching)
依然发生在一个或者一组松散的操作之上。
想要定制已有操作，或者把几个操作进行强结合以便给模式匹配设定清晰边界，依旧很困难。</p>
<p>MLIR 中操作的一个突出特性是可以通过 <a href="https://mlir.llvm.org/docs/LangRef/#regions">region</a> 来内嵌 (nest) 结构 (structure)。
MLIR 中很多可以添加负载操作 (payload op) 的结构化操作 (structured op) 都依赖于这种特性。
这些结构化操作本身只定义某种结构性语义，比如控制流 (control flow)。
具体的计算性语义则来自于添加的负载操作。结构化操作与负载操作相互组合、相互扩展。
一个突出的例子是 <a href="https://mlir.llvm.org/docs/Dialects/Linalg/#payload-carrying-opsa-namepayload_opsa"><code>linalg.generic</code> op</a>；
当然函数 (function) 以及模块 (module) 其实都是这种结构化操作。
Region 给负载操作设置了明确的边界，这有助于简化中间表示转换时所需的模式匹配。</p>
<h3 id="代表抽象层次的类型">代表抽象层次的类型</h3>
<p>操作归根到底只是针对某种类型的值 (value) 所进行的某种计算 (computation)。
类型才是抽象层次 (abstraction level) 的代表。
举个栗子，张量 (tensor)、buffer、以及标量 (scalar) 都可以支持加减乘除等各种操作。
这些操作在本质上并没有多少区别，但它们明显属于不同的抽象层次。
张量存在于机器学习框架或者编程模型 (programming model) 这一高层抽象。
Buffer 存在于执行系统 (system) 和内存体系 (memory hierarchy) 这一中层抽象。
标量存在于执行芯片 (chip) 和寄存器 (register) 这一底层抽象。</p>
<p>一个 dialect 可以自由地定义各种类型。
MLIR 的核心基础设施会无差别地对待以及用统一的机制支持来自不同 dialect 的类型。
比如，<a href="https://mlir.llvm.org/docs/DialectConversion/#type-conversion"><em>type conversion</em></a> 就是通用的转换类型的机制。
Dialect A 可以重用来自 dialect B 的类型，也可以对其进一步扩展和组合，例如将基础类型 (primitive type) 放入容器类型中 (container type)。
一个 dialect 也可以定义规则来实现自身类型和其他 dialect 类型的相互转换。
把这些规则加入到 type converter 中后，所有的规则会相互组合，由此 type conversion 机制会自行找出转换通路来实现转换。
不过总而言之，相较于操作的组合与转换，类型的组合以及转换通常有更多限制也更加复杂，毕竟类型的匹配奠定了操作可以衔接的基础。</p>
<h3 id="作为建模粒度的-dialect">作为建模粒度的 dialect</h3>
<p>通过定义和组织操作和类型，dialect 给编译器提供了粗粒度高层次的建模方式。
如果两个 dialect 所涉及的类型相同，那么它们基本属于统一抽象层次。
另一方面，对涉及不同类型的 dialect 进行转换本质上则是转换不同的抽象层次。</p>
<p><strong>为简化实现，我们一般将高层次 (high-level) 抽象递降 (lower) 到低层次 (low-level) 抽象。</strong>
<strong>递降的过程通常会进行某种形式的问题分解 (decomposition) 或者资源分配 (resource assignment) 来逐渐贴近底层硬件。</strong>
前者的例子有 tiling, vectorization 等等；后者的例子有 bufferization, 寄存器分配 (register allocation) 等等。
即便如此，递降依然不是一个简单的问题，因为不同的抽象层次有不同的目的以及对正确性和性能的理解。
比如编程模型层考虑的是代码的表示能力以及简洁性，很少涉及具体硬件特性；
而硬件层考虑的是资源的最佳使用，很少考虑易于编程。
因此，在诸多 MLIR 机制中，<a href="https://mlir.llvm.org/docs/DialectConversion/"><em>dialect conversion</em></a> 可能是最复杂的就并不奇怪了。</p>
<h2 id="dialect-体系">Dialect 体系</h2>
<p>以操作和类型的可组合性以及可扩展性为基础，dialect 可以作为组合机器学习编译器的高层次基础组件。
之前的讨论偏抽象，接下来我会具体地介绍具体现有的 dialect，并把它们放到统一的流程中。
鉴于这里的目的是提供宏观的理解，讨论只会涉及主要的部分，而非对所有 dialect 进行详细的分析。</p>
<h3 id="问题空间">问题空间</h3>
<p>首先，让我们看一下问题空间 (problem space) 并且定义讨论的边界。
机器学习编译器面临<strong>深度</strong>和<strong>广度</strong>的双重挑战&mdash;</p>
<ul>
<li>在最上层，模型通常是基于某种框架用 Python 编写的。
输入程序，或者说编程模型 (programming model)，通常是对高维张量 (high-D tensor) 进行操作。
而在最底层，模型的主要计算部分通常是由某种具有向量或者 SIMD 单元的加速器执行的。
底层硬件，或者说机器模型 (machine model)，只提供低维（通常是一或者二）向量 (low-D vector)
或者标量的指令。</li>
<li>现在有各种各样的框架可以用于编写机器学习模型，同样有许许多多的硬件可以执行它们。
硬件可能会提供不同的计算和内存组织结构；在 CPU、GPU 以及各种加速器中，tile-based
架构是一种较常见的一种。
整个模型的执行需要运行各种控制流以及同步机制，在这方面 GPU 或者一般的加速器通常都乏善可陈，
所以 CPU 依然处于中心进行调度协调。</li>
</ul>
<p><strong>真正的端到端的机器学习编译器需要将输入的模型同时转换成运行在加速器上的算子 (kernel) 和运行在 CPU 上的调度同步逻辑。</strong>
MLIR 生态中两部分都有其对应的 dialect 体系。
本文的侧重是算子代码生成；调度同步相关的 dialect (例如 MLIR 中的 <a href="https://mlir.llvm.org/docs/Dialects/AsyncDialect/"><code>async</code> dialect</a>
和 IREE 中的 <a href="https://github.com/google/iree/tree/5947c0837f8bba664babd4b4383a955a7249be64/iree/compiler/Dialect/Stream"><code>stream</code> dialect</a>) 与传统运行时系统 (runtime) 的功能相关，
值得另起文章来介绍。</p>
<h3 id="宏观图景">宏观图景</h3>
<p>从类型的角度，恰当分层的软件栈需要支持对张量、buffer、向量、标量等进行建模以及一步步分解和递降。
从操作的角度，我们需要计算和控制流。控制流可以是显式的基础块跳转，也可以内含于结构化操作之中。
通过这些角度把以下会讨论的 dialect 展示在同一流程中：</p>
<p><img src="codegen-dialect-hierarchy.svg" alt="MLIR CodeGen Dialect Hierarchy" title="MLIR CodeGen Dialect Hierarchy"></p>
<h3 id="高层用于描述模型的-dialect">高层用于描述模型的 dialect</h3>
<p>自顶向下来看，原始模型是用某一框架来表示的。
原始模型通过直接转换成这个框架相对应的 dialect（例如 TensorFlow 的 <a href="https://github.com/tensorflow/tensorflow/tree/1cffc0a1946413f8d0237e67d29891649f789c87/tensorflow/compiler/mlir/tensorflow/ir"><code>tf</code> dialect</a>,
TFLite 的 <a href="https://github.com/tensorflow/tensorflow/tree/1cffc0a1946413f8d0237e67d29891649f789c87/tensorflow/compiler/mlir/lite/ir"><code>tfl</code> dialect</a>, PyTorch 的 <a href="https://github.com/llvm/torch-mlir/tree/abbde7d439836ab359f64f84ba1f1740f06c765b/include/torch-mlir/Dialect/Torch/IR"><code>torch</code>dialect</a>）
来导入 (import) 到 MLIR 系统中。
这些对应于具体框架的 dialect 的目的是准确地表示原模型的结构和语义，因为这种紧密的联系，它们通常存在于相应框架的代码库中。</p>
<p>面对深度和广度的双重挑战，<strong>复杂度可控的编译器栈需要具有沙漏 (hourglass) 的结构。</strong>
在模型导入之后，我们需要将各种框架表示转换成统一的用于表示模型的 dialect，
以便作为接下来的递降过程的输入。
MLIR 在这一层的支持还在迅速演进中，将来希望能够看到一系列（存在于一个或者多个 dialect 中）协调的定义，
用于完整地表示来自于各种框架的各种模型，并且提供所需的兼容性支持。
就目前而言，这一层有 <a href="https://github.com/tensorflow/mlir-hlo"><code>mhlo</code> dialect</a> 和 <a href="https://mlir.llvm.org/docs/Dialects/TOSA/"><code>tosa</code> dialect</a>。
前者由 <a href="https://www.tensorflow.org/xla">XLA</a> 而生，是 TensorFlow 系与 MLIR 的桥梁；
后者是 TOSA 规范的具体实现。TOSA 规范明确定义很多计算的数值要求，被越来越多的框架转换所采用。</p>
<h3 id="中间层用于递降的-dialect">中间层用于递降的 dialect</h3>
<p>高层和低层的 dialect 通常处于 MLIR 系统的边界，所以需要准确地描述某一 MLIR 之外的标的。
中间层的 dialect 则没有这样的限制，所以中间层的 dialect 具有更大的设计空间以及更高的设计灵活性。</p>
<p>传统的中间表示，如 LLVM IR 或者 SPIR-V，通常都是完整 (<em>complete</em>) 的；
它们包含所需的所有指令来表示整个 CPU 后者 GPU 程序。相较而言，中间层的 dialect
则可以认为是部分 (<em>partial</em>) 中间表示。
这种组织结构有助于解耦 (decoupling) 和可组合性&mdash;我们可以通过混用这一层的不同 dialect 来表示原始模型，同时不同 dialect 可以独立发展演进。
这些dialect 有的用来表示计算或者负载 (payload)，有的则表示控制流或者某种结构 (structure)。</p>
<h4 id="linalg-dialect">linalg dialect</h4>
<p><a href="https://mlir.llvm.org/docs/Dialects/Linalg/"><code>linalg</code> dialect</a> 是用以表示结构的重要 dialect 之一。
<code>linalg</code> op 的本质是完美嵌套循环 (perfect loop nest)。<code>linalg</code> op 通过其 indexing map
来指定循环变量 (loop induction variable) 如何访问 (access) 操作数 (operand) 以及结果 (result)。
<code>linalg</code> op region 内的负载操作则指定了循环内部所进行的计算。
完美嵌套循环在 <code>linalg</code> op 中是隐性的，这一核心特性简化了很多的分析以及转换。
例如，要融合 (fuse) 两个完美嵌套循环，传统上需要分析每个循环变量的范围 (range) 以及它们如何访问元素，
这是比较复杂的分析逻辑，之后的转换也同样比较复杂。
用 <code>linalg</code> op 的 indexing map 来隐性表示嵌套循环则可以把上面的过程<a href="https://github.com/llvm/llvm-project/blob/8f310d1967c20d348c617af3a30999031c71fee0/mlir/lib/Dialect/Linalg/Transforms/Fusion.cpp#L537">简化为
<code>inverse(producerIndexMap).compose(consumerIndexMap)</code> 这一步骤</a>。
除此之外，<code>linalg</code> dialect 的<a href="https://mlir.llvm.org/docs/Dialects/Linalg/#high-level-description-of-linalg-opsa-namelinalg_opsa">文档中还有许多其他不错的设计考虑</a>值得一读。</p>
<p><code>linalg</code> dialect 中有很多结构化操作，它们分为两大类：&ldquo;generic&rdquo; op 以及 &ldquo;named&rdquo; op。
前者只包括 <a href="https://mlir.llvm.org/docs/Dialects/Linalg/#linalggeneric-mlirlinalggenericop"><code>linalg.generic</code> op</a>。
这个是核心的结构化操作，也是所有结构化 <code>linalg</code> op 的原始未包装形式。
Named op (例如 <a href="https://github.com/llvm/llvm-project/blob/8f310d1967c20d348c617af3a30999031c71fee0/mlir/python/mlir/dialects/linalg/opdsl/ops/core_named_ops.py#L10-L21"><code>linalg.matmul</code> op</a> 以及<a href="https://github.com/llvm/llvm-project/blob/8f310d1967c20d348c617af3a30999031c71fee0/mlir/python/mlir/dialects/linalg/opdsl/ops/core_named_ops.py#L222-L336">各种 <code>linalg.conv*</code> op</a>)
只是对具有特定 indexing map 以及负载操作的 <code>linalg.generic</code> op 进行包装的语法糖。
我们可以很简单地把 named op <a href="https://github.com/llvm/llvm-project/blob/8f310d1967c20d348c617af3a30999031c71fee0/mlir/lib/Dialect/Linalg/Transforms/Generalization.cpp">转换成</a>其对应的 generic 形式。
<code>linalg</code> op 背后统一的结构有助于简化转换的逻辑，
因为转换只需要针对 indexing map 以及 region 进行操作，而无需考虑这具体是哪一个 <code>linalg</code> op。</p>
<p><code>linalg</code> op 既可以操作张量也可以操作 buffer。这两者分别对应于 MLIR 中的 <code>tensor</code> and <code>memref</code> 类型。
两者皆是高维的抽象，并都可以支持 dynamic shape。</p>
<h4 id="tensor-tiling-以及-fusion">Tensor, tiling 以及 fusion</h4>
<p><code>mhlo</code> 和 <code>tosa</code> dialect 都可以转换成 <code>linalg</code> dialect。
这种转换会保持在张量这一抽象层级，所以其目的并非递降，而是为接下来的转换做准备。
<a href="https://www.tensorflow.org/mlir/hlo_ops#mhlodot_general_mlirmhlodotgeneralop"><code>mhlo.dot_general</code> op</a> 和 <a href="https://mlir.llvm.org/docs/Dialects/TOSA/#tosamatmul-mlirtosamatmulop"><code>tosa.matmul</code>
op</a> 都可以表示 batch matmul，那么 <a href="https://mlir.llvm.org/docs/Dialects/Linalg/#linalgbatch_matmul-mlirlinalgbatchmatmulop"><code>linalg.batch_matmul</code>
op</a> 的意义何在呢？
因为隐性嵌套循环，<a href="https://github.com/llvm/llvm-project/blob/14f143c9084fc49b45f30a199dc8a16b7506f959/mlir/lib/Dialect/Linalg/Transforms/FusionOnTensors.cpp#L412"><em>tiling</em> 和 <em>fusion</em></a>
这些对 tile-based 架构非常重要的转换在 <code>linalg.batch_matmul</code> op
上进行更加方便&mdash;我们只需要创建显式的嵌套循环，把之前的 <code>linalg</code> op 转移到其内并且缩小 <code>linalg</code> op
操作的范围到一个 slice 就可以了。</p>
<p>比如下面的 <code>tosa.conv2d</code> op：</p>
<pre><code>%0 = &quot;tosa.conv2d&quot;(%input, %filter, %bias)
       {dilation = [1, 1], pad = [0, 0, 0, 0], stride = [2, 2]}
     : (tensor&lt;1x225x225x3xf32&gt;, tensor&lt;32x3x3x3xf32&gt;, tensor&lt;32xf32&gt;)
     -&gt; tensor&lt;1x112x112x32xf32&gt;
</code></pre>
<p>转换成 <code>linalg</code> op 并进行 tiling 和 fusion 之后：</p>
<pre><code>%0 = scf.for %iv0 = ... to ... step ... iter_args(...) -&gt; (tensor&lt;1x112x112x32xf32&gt;) {
  %1 = scf.for ... {
    %input_slice = tensor.extract_slice ...
    %filter_slice = tensor.extract_slice ...
    %bias_slice = tensor.extract_slice ...
    %conv = linalg.conv_2d_nhwc_hwcf {...} ins(%input_slice, %filter_slice) ...
    %generic = linalg.generic ins(%conv, %bias_slice} ... {
      %add = arith.addf ...
      linalg.yield %add ...
    }
    scf.yield %generic
  }
  scf.yield %1
}
</code></pre>
<p>在嵌套循环之内，我们依然维持着 <code>linalg</code> named op 的形态，以便于进一步的 tiling 和 fusion，
或者进行其他的模式匹配和转换。</p>
<h4 id="buffer-distribution">Buffer, distribution</h4>
<p>至此我们只讨论了张量。张量是不可变的 (immutable)、不可分割的 (integral) 个体，并且不具有 side effect。
张量的 SSA def-use chain 可以用于数据流的分析。针对张量的转换因此比较简单。
不过在整个流程的某一步，我们需要把张量转换成 buffer。
这一转换在 MLIR 中称为 <a href="https://mlir.llvm.org/docs/Bufferization/"><em>bufferization</em></a>。
Buffer 是可变的 (mutable)、可 alias 的；buffer 上的转换通常需要比较复杂的依赖分析
(dependency analysis) 和别名分析 (alias analysis)。
所以<strong>在 MLIR 中趋势是将 bufferization 尽量推后，放在 vectorization 之后</strong>。
这样 bufferization 可能就会完全变成机械性 (mechanical) 的转换而无需特别复杂的逻辑。
因为 vectorization 之后可以通过 read/write forwarding/cancelling 等手段来减少中间的张量结果，从而去掉对 buffer 的需求。</p>
<p>Bufferization 是不同抽象层次之间的递降&mdash;抽象的值被安排到了具体的内存中的资源。
如何进行这种分配既有技术方面也有策略 (policy) 方面的考量。
我们即需要避免资源冲突 (hazard) 也要避免无谓的数据复制。
这一部分在 MLIR 中还在快速演进中。</p>
<p>Bufferization 之后，我们可以进行 <em>distribution</em> 来将 problem tile 分配到
hardware tile (比如 CPU thread, GPU workgroup,
GPU workitem 等等)。
沿用之前的例子，在 bufferization 以及 distribution 之后，代码会变成：</p>
<pre><code>scf.for %ivz = (%idz * %tilez) to %ubz step (%countz * %tilez) {
  scf.for ... {
    %input_subview = memref.subview ...
    %filter_subview = memref.subview ...
    %bias_subview = memref.subview ...
    %output_subview = memref.subview ...
    linalg.conv_2d_nhwc_hwcf {...}
      ins(%input_subview, %filter_subview) outs(%output_subview) ...
    linalg.generic
      ins(%output_subview, %bias_subview) outs(%ouput_subview) ... {
      %add = arith.addf ...
      linalg.yield %add ...
    }
  }
}
</code></pre>
<h4 id="tensor-memref-arith-math-dialect">tensor, memref, arith, math dialect</h4>
<p>上面的流程中也涉及了 <a href="https://mlir.llvm.org/docs/Dialects/TensorOps/"><code>tensor</code> dialect</a>,
<a href="https://mlir.llvm.org/docs/Dialects/MemRef/"><code>memref</code> dialect</a>, <a href="https://mlir.llvm.org/docs/Dialects/ArithmeticOps/"><code>arith</code> dialect</a> 和
<a href="https://mlir.llvm.org/docs/Dialects/MathOps/"><code>math</code> dialect</a>.</p>
<p><code>tensor</code> 和 <code>memref</code> dialect 包含了对张量和 buffer 的操作。
比如在之前的流程中，<code>tensor.*slice</code> 和 <code>memref.subview</code> op 辅助表示 tiled IR structure。
<code>tensor</code> 和 <code>memref</code> dialect 中还包含其他的用以产生 <code>tensor</code>/<code>memref</code>、对 shape 进行操作、
或者一些难以表示成结构性操作或者负载操作的操作。</p>
<p><code>arith</code> and <code>math</code> op 则用以表示整数或者浮点数计算。
它们通常用以作为负载操作，并且可以支持各种抽象层级（包括张量、向量、标量等等）。
所以在之前的流程图中，它们基本出现在每一层。</p>
<h4 id="vector-dialect">vector dialect</h4>
<p><code>vector</code> dialect 是除 <code>linalg</code> dialect 之外的另一个重要的用于结构化代码生成 (structured
code generation) 的 dialect。</p>
<p>如果说张量处于抽象的编程模型这一层级，buffer 属于具体的系统内存这一层级，那么向量则处于芯片寄存器这一层级。
因为更加贴近硬件实现，向量有着更多的限制。
在一个模型中，我们通常可以使用无限多个张量。Bufferization 是一次资源分配；它把张量分配到了内存中的 buffer。
在这一过程中我们可以重用同一 buffer 来减小内存使用量或者避免不必要的数据复制。
一般而言，内存比较灵活。比如，内存支持动态索引 (dynamic indexing)，并且容量 (capacity) 很大。
向量则不同。一般向量要求静态索引 (static indexing)，并且通常数量稀少。
如何有效利用寄存器和 vector/SIMD/SIMT 计算单元来高效存取和处理向量是另一次具有更多限制和折中的资源分配。</p>
<p>在 MLIR 中，<code>vector</code> dialect <a href="https://mlir.llvm.org/docs/Dialects/Vector/#components-of-a-generic-retargetable-vector-level-dialect">本身即是多层次的</a>。
除了支持机器原生 (machine-native) 的向量操作之外，它也支持高维的机器无关的 (machine-agnostic) 虚拟向量。
<strong>核心想法是通过渐进递降 (progressive lowering) 来将高维的机器无关的虚拟向量分解成低维的机器原生的向量。</strong></p>
<h4 id="vectorization-unrolling-hoisting-canonicalization">Vectorization, unrolling, hoisting, canonicalization</h4>
<p><code>linalg</code> dialect 可以 tiling 来创建大小已知的 tile。
之后我们可以通过 <a href="https://github.com/llvm/llvm-project/blob/14f143c9084fc49b45f30a199dc8a16b7506f959/mlir/lib/Dialect/Linalg/Transforms/Vectorization.cpp"><em>vectorization</em></a> 来将每个 tensor/buffer tile
转换成同一 shape 的 vector tile。
Vectorization 会生成 <a href="https://mlir.llvm.org/docs/Dialects/Vector/#vectortransfer_read-mlirvectortransferreadop"><code>vector.transfer_read</code> op</a> 来读取
tensor/buffer 中的内容到虚拟 vector，然后生成 <code>vector</code> (例如
<a href="https://mlir.llvm.org/docs/Dialects/Vector/#vectorextract-mlirvectorextractop"><code>vector.contract</code> op</a>) 或者 <code>arith</code> op 来对虚拟 vector 进行计算，
最后会生成 <a href="https://mlir.llvm.org/docs/Dialects/Vector/#vectortransfer_write-mlirvectortransferwriteop"><code>vector.transfer_write</code> op</a> 来将结果写回 tensor/buffer。
Vector transfer op 可以表示各种模式的内存读取与写入，也包括对 stride 和 padding 的支持。</p>
<p>这里所说的 vectorization 并非传统的 vectorization。传统的 vectorization
需要将抽象层级从标量递升 (raise) 到向量。
在 MLIR 中，vectorization 也同样转换抽象层级，不过是递降 (lower)，并且基本是机械性的 (mechanical)，
因为在 vectorization 过程中我们并不改变 shape。</p>
<p>Vectorization 之后，我们可以进一步使用 <a href="https://github.com/llvm/llvm-project/blob/14f143c9084fc49b45f30a199dc8a16b7506f959/mlir/include/mlir/Dialect/Vector/Transforms/VectorRewritePatterns.h#L280-L311"><em>unrolling</em></a> 和
<em>decomposition</em> 来将高维的向量 <a href="https://github.com/llvm/llvm-project/blob/14f143c9084fc49b45f30a199dc8a16b7506f959/mlir/include/mlir/Dialect/Vector/Transforms/VectorRewritePatterns.h#L130-L175">递降到</a> 符合目标架构的低维向量。
机器无关的 <code>vector</code> op 可以进一步转换成机器原生的，比如由 <code>vector.contract</code>
op 到 <a href="https://mlir.llvm.org/docs/Dialects/Vector/#vectorfma-mlirvectorfmaop"><code>vector.fma</code> op</a>。</p>
<p>Unrolling, decomposition 以及 lowering 之后，<a href="https://github.com/llvm/llvm-project/blob/14f143c9084fc49b45f30a199dc8a16b7506f959/mlir/include/mlir/Dialect/Linalg/Transforms/Hoisting.h"><em>hoisting</em></a> 以及各种
<em>canonicalization</em> 有助于进一步清理中间表示。
这其中各种 forward/cancel read/write 以及 insert/extract op 对的转换尤其重要。</p>
<p>在这些转换之后，之前的例子会变成：</p>
<pre><code>scf.for %ivz = (%idz * %tilez) to %ubz step (%countz * %tilez) {
  scf.for ... {
    %input_subview = memref.subview ...
    %filter_subview = memref.subview ...
    %bias_subview = memref.subview ...
    %output_subview = memref.subview ...
    vector.transfer_read %input_subview ...
    vector.transfer_read %filter_subivew ...
    ...
    %v0 = vector.fma ...
    %v1 = vector.fma ...
    ...
    vector.transfer_write %v0, %output_subview ...
    vector.transfer_write %v1, %output_subview ...
    ...
  }
}
</code></pre>
<p><code>vector</code> dialect 使用了 dialect 内部的转换来进行渐进式递降。
因此，pattern 一般比较简单和机械化，组合起来却能真正显示它们的威力。
不过要想恰当地排列并且使用它们却是比较难的。在这一方面 <code>vector</code> dialect 需要进一步改善。</p>
<h4 id="scf-cf-dialect">scf, cf dialect</h4>
<p><code>linalg</code> dialect 之后的各层使用 <a href="https://mlir.llvm.org/docs/Dialects/SCFDialect/"><code>scf</code> dialect</a> 的架构化操作。
<code>scf</code> dialect 包含有 structured control flow op, 比如用于分支的 <a href="https://mlir.llvm.org/docs/Dialects/SCFDialect/#scfif-mlirscfifop"><code>scf.if</code>
op</a> 以及用于循环的 <a href="https://mlir.llvm.org/docs/Dialects/SCFDialect/#scffor-mlirscfforop">the <code>scf.for</code> op</a>。
这些操作显示地表示循环变量的范围。不过它们依然使用 region 来标明边界，这有助于简化分析和转换。
一旦我们生成了最终形态的控制流，trip-one distributed loop nest 可以被彻底消除，
剩下的循环可以进一步转换成基础块以及 <a href="https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/"><code>cf</code> op</a>。</p>
<p>到此为止，我们已经接近整个转换流程的终点。
下一步是进行整体 dialect conversion 来导出 (export) 到其他的系统。</p>
<h3 id="底层用于描述目标的-dialect">底层用于描述目标的 dialect</h3>
<p>在 MLIR 中目前有两个底层 dialect：<a href="https://mlir.llvm.org/docs/Dialects/LLVM/"><code>llvm</code> dialect</a> 和 <a href="https://mlir.llvm.org/docs/Dialects/SPIR-V/"><code>spv</code> dialect</a>。
它们分别用来对 LLVM IR 和 SPIR-V 建模。
转换成任何一个都是对导出到外部系统的准备。
因为这两个 dialect 描述外部中间表示，它们在类型和指令方面受相应的限制。
递降到 <code>llvm</code> 或者 <code>spv</code> dialect 需要进行整体的 dialect conversion；
完成之后 IR 中不再有任何的非 <code>llvm</code> 或者 <code>spv</code> dialect 的操作。</p>
<p>一般而言，<strong>上层应该已经完成各种优化，在这个层次不会再有。</strong>
这个层次的转换多是普适的 canonicalization 和清理，以及一些用以<strong>保障合法性</strong>的转换。</p>
<h2 id="结语">结语</h2>
<p>机器学习编译器面临深度和广度两方面的挑战。MLIR 提供了 dialect 这一更高层次的基础组件来应对这些挑战。
理想情况下具体的机器学习编译器只需要组合现有的 dialect，并加以自己的扩展或者定制。
相对于组合来自于各种层次的操作而言，这是更粗粒度的一种构建方式。
每个 dialect 都包含一套协调的操作和类型，这种构建方式更加易于管理，会带来结构层次更加清晰的软件栈。
当然，这一愿景需要一些时间来完全实现！</p>
<p>文中的转换流程列出了与代码生成相关的主要 dialect 和转换。
总而言之，MLIR 比较推崇将高层次抽象递降到低层次抽象。
递降的过程通常会进行某种形式的问题分解或者资源分配来逐渐贴近底层硬件。
Dialect 和 pattern 都是为了实现这一目的；它们的设计注重尽量最小化分析和转换，以及最大化可组合性。</p>
<p>本文之外，<a href="https://llvm.discourse.group/t/codegen-dialect-overview/2723">Alex&rsquo;s 在 Discourse 上面的 post</a> 和<a href="https://arxiv.org/abs/2202.03293">一篇新的 paper</a> 也有对代码生成流程的讨论。
后面的文章中，我会进一步解释运行时系统和调度同步相关的 dialect。挖坑待填！😊</p>
        </div>
        
        <div class="my-4">
    
    <a href="https://www.lei.chat/zh/tags/mlir/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>mlir</a>
    
    <a href="https://www.lei.chat/zh/tags/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>代码生成</a>
    
    <a href="https://www.lei.chat/zh/tags/dialect/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>dialect</a>
    
    <a href="https://www.lei.chat/zh/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>机器学习</a>
    
    <a href="https://www.lei.chat/zh/tags/%E7%BC%96%E8%AF%91%E5%99%A8/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>编译器</a>
    
    <a href="https://www.lei.chat/zh/tags/tf/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>tf</a>
    
    <a href="https://www.lei.chat/zh/tags/torch/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>torch</a>
    
    <a href="https://www.lei.chat/zh/tags/mhlo/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>mhlo</a>
    
    <a href="https://www.lei.chat/zh/tags/tosa/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>tosa</a>
    
    <a href="https://www.lei.chat/zh/tags/linalg/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>linalg</a>
    
    <a href="https://www.lei.chat/zh/tags/tensor/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>tensor</a>
    
    <a href="https://www.lei.chat/zh/tags/memref/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>memref</a>
    
    <a href="https://www.lei.chat/zh/tags/vector/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>vector</a>
    
    <a href="https://www.lei.chat/zh/tags/scf/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>scf</a>
    
    <a href="https://www.lei.chat/zh/tags/cf/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>cf</a>
    
    <a href="https://www.lei.chat/zh/tags/arith/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>arith</a>
    
    <a href="https://www.lei.chat/zh/tags/math/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>math</a>
    
    <a href="https://www.lei.chat/zh/tags/llvm/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>llvm</a>
    
    <a href="https://www.lei.chat/zh/tags/spirv/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>spirv</a>
    
    <a href="https://www.lei.chat/zh/tags/%E4%BD%93%E7%B3%BB/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>体系</a>
    
    <a href="https://www.lei.chat/zh/tags/%E7%B1%BB%E5%9E%8B/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>类型</a>
    
    <a href="https://www.lei.chat/zh/tags/%E6%93%8D%E4%BD%9C/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>操作</a>
    
    <a href="https://www.lei.chat/zh/tags/tiling/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>tiling</a>
    
    <a href="https://www.lei.chat/zh/tags/fusion/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>fusion</a>
    
    <a href="https://www.lei.chat/zh/tags/distribution/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>distribution</a>
    
    <a href="https://www.lei.chat/zh/tags/vectorization/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>vectorization</a>
    
    <a href="https://www.lei.chat/zh/tags/unrolling/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>unrolling</a>
    
    <a href="https://www.lei.chat/zh/tags/hoisting/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>hoisting</a>
    
    <a href="https://www.lei.chat/zh/tags/canonicalization/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka"><i class="fas fa-tags mr-1"></i>canonicalization</a>
    
</div>

        
        
        


        
        
        
        
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
        <span class="block font-bold">上一页</span>
        <a href="https://www.lei.chat/zh/posts/mlir-vector-dialect-and-patterns/" class="block">MLIR Vector Dialect 以及 Patterns</a>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">下一页</span>
        <a href="https://www.lei.chat/zh/posts/compilers-and-irs-llvm-ir-spirv-and-mlir/" class="block">编译器与中间表示: LLVM IR, SPIR-V, 以及 MLIR</a>
        
    </div>
</div>

        



  <script id="utterances" src="https://utteranc.es/client.js"
            issue-term=title
            repo=antiagainst/antiagainst.github.io
              theme=preferred-color-scheme
        crossorigin="anonymous"
        async>
</script>
<script>
    if (storageColorScheme == "Light") {
      document.getElementById('utterances').setAttribute('theme', 'github-light')
    } else if (storageColorScheme == "Dark") {
      document.getElementById('utterances').setAttribute('theme', 'github-dark')
    }
</script>

    </div>
    
    <div class="col-span-2">
        
        
<div class="bg-secondary-bg rounded p-6">
    <h3 class="text-lg font-semibold mb-4">系列文章</h3>
    <div class="content">
        
          
          <span class="font-semibold">
            <i class="fas fa-th-list mr-1"></i>编译器开发 »
          </span>
          <br />
          
            <span>1.</span>
            <a href="https://www.lei.chat/zh/posts/compilers-and-irs-llvm-ir-spirv-and-mlir/">编译器与中间表示: LLVM IR, SPIR-V, 以及 MLIR</a>
            <br />
          
            <span>2.</span>
            <a href="https://www.lei.chat/zh/posts/mlir-codegen-dialects-for-machine-learning-compilers/">机器学习编译器代码生成相关 MLIR Dialect</a>
            <br />
          
            <span>3.</span>
            <a href="https://www.lei.chat/zh/posts/mlir-vector-dialect-and-patterns/">MLIR Vector Dialect 以及 Patterns</a>
            <br />
          
            <span>4.</span>
            <a href="https://www.lei.chat/zh/posts/mlir-linalg-dialect-and-patterns/">MLIR Linalg Dialect 以及 Patterns</a>
            <br />
          
        
    </div>
</div>

        
        
        <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-primary-bg ">
    <span class="text-lg font-semibold">本页内容</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6 ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#基础组件">基础组件</a>
      <ul>
        <li><a href="#内嵌结构的操作">内嵌结构的操作</a></li>
        <li><a href="#代表抽象层次的类型">代表抽象层次的类型</a></li>
        <li><a href="#作为建模粒度的-dialect">作为建模粒度的 dialect</a></li>
      </ul>
    </li>
    <li><a href="#dialect-体系">Dialect 体系</a>
      <ul>
        <li><a href="#问题空间">问题空间</a></li>
        <li><a href="#宏观图景">宏观图景</a></li>
        <li><a href="#高层用于描述模型的-dialect">高层用于描述模型的 dialect</a></li>
        <li><a href="#中间层用于递降的-dialect">中间层用于递降的 dialect</a>
          <ul>
            <li><a href="#linalg-dialect">linalg dialect</a></li>
            <li><a href="#tensor-tiling-以及-fusion">Tensor, tiling 以及 fusion</a></li>
            <li><a href="#buffer-distribution">Buffer, distribution</a></li>
            <li><a href="#tensor-memref-arith-math-dialect">tensor, memref, arith, math dialect</a></li>
            <li><a href="#vector-dialect">vector dialect</a></li>
            <li><a href="#vectorization-unrolling-hoisting-canonicalization">Vectorization, unrolling, hoisting, canonicalization</a></li>
            <li><a href="#scf-cf-dialect">scf, cf dialect</a></li>
          </ul>
        </li>
        <li><a href="#底层用于描述目标的-dialect">底层用于描述目标的 dialect</a></li>
      </ul>
    </li>
    <li><a href="#结语">结语</a></li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
        
    </div>
    

    
    
    <div
        class="col-span-2  lg:col-span-6 bg-secondary-bg rounded p-6">
        <h2 class="text-lg font-semibold mb-4">相关</h2>
        <div class="content">
            
            <a href="https://www.lei.chat/zh/posts/compilers-and-irs-llvm-ir-spirv-and-mlir/">编译器与中间表示: LLVM IR, SPIR-V, 以及 MLIR</a>
            <br />
            
        </div>
    </div>
    
</div>
<script>
    document.addEventListener('DOMContentLoaded', ()=>{
        hljs.initHighlightingOnLoad();
    })
</script>

      </div>
    </div>
    
  </main>
  <footer class="pl-scrollbar">
    <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2018 - 2023 <a href="https://www.lei.chat/">Lei Zhang</a>
 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
  </footer>
</body>

</html>