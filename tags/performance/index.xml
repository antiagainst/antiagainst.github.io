<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>performance on Lei.Chat()</title>
    <link>https://www.lei.chat/tags/performance/</link>
    <description>Recent content in performance on Lei.Chat()</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; 2018 - 2025 &lt;a href=&#34;https://www.lei.chat/&#34;&gt;Lei Zhang&lt;/a&gt;
</copyright>
    <lastBuildDate>Tue, 31 Dec 2024 14:21:28 -0800</lastBuildDate><atom:link href="https://www.lei.chat/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Triton Linear Layout: Concept</title>
      <link>https://www.lei.chat/posts/triton-linear-layout-concept/</link>
      <pubDate>Tue, 31 Dec 2024 14:21:28 -0800</pubDate>
      
      <guid>https://www.lei.chat/posts/triton-linear-layout-concept/</guid>
      <description>&lt;p&gt;Layout is a core concept in Triton for representing and optimizing distribution
mappings from source problems to the target hardware compute and memory
hierarchy.
In this blog post I will talk about linear layout in Triton, the new unifying
mechanism over existing bespoke layouts for different purposes.
The aim is to provide motivation and an intuitive understanding of linear
layout;
I will rely on examples and illustrations instead of theories and proofs.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android Native Library Benchmarking Pipeline for Open Source Projects</title>
      <link>https://www.lei.chat/posts/android-native-library-benchmarking-pipeline-for-open-source-projects/</link>
      <pubDate>Sat, 21 Aug 2021 22:47:43 -0400</pubDate>
      
      <guid>https://www.lei.chat/posts/android-native-library-benchmarking-pipeline-for-open-source-projects/</guid>
      <description>&lt;p&gt;Today I would like to describe one way to build a scalable and frictionless
benchmarking pipeline for Android native libraries, aiming to support different
benchmark and device variants.
It is for open source projects, so it composes public services, commonly
free under such conditions.
The ingredients are cloud virtual machines for building, local single board
computers (e.g., Raspberry Pi) for hosting Android devices and executing
benchmarks, a &lt;a href=&#34;https://github.com/google/dana&#34;&gt;Dana&lt;/a&gt; server for keeping track of benchmark results of
landed changes, and Python scripts for posting benchmark comparisons to pull
requests.
A &lt;a href=&#34;https://buildkite.com&#34;&gt;Buildkite&lt;/a&gt; pipeline chains them together and drives the full flow.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sampling Performance Counters from Mobile GPU Drivers</title>
      <link>https://www.lei.chat/posts/sampling-performance-counters-from-gpu-drivers/</link>
      <pubDate>Thu, 08 Jul 2021 19:16:41 -0400</pubDate>
      
      <guid>https://www.lei.chat/posts/sampling-performance-counters-from-gpu-drivers/</guid>
      <description>&lt;p&gt;In a &lt;a href=&#34;../android-linux-gpu-drivers-internals-and-resources&#34;&gt;previous blog post&lt;/a&gt; I gave a general introduction
to GPU driver internals in Android/Linux systems. Following up with it, today
I will explain how a specific functionality, hardware performance counter
(perf counter) queries, is handled in both Qualcomm Adreno and ARM Mali drivers,
by walking through the kernel driver source code.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
