<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gpu on Lei.Chat()</title>
    <link>https://www.lei.chat/tags/gpu/</link>
    <description>Recent content in gpu on Lei.Chat()</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; 2018 - 2023 &lt;a href=&#34;https://www.lei.chat/&#34;&gt;Lei Zhang&lt;/a&gt;
</copyright>
    <lastBuildDate>Sat, 01 Apr 2023 14:02:36 -0700</lastBuildDate><atom:link href="https://www.lei.chat/tags/gpu/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Single-node ML Runtime Foundation</title>
      <link>https://www.lei.chat/posts/single-node-ml-runtime-foundation/</link>
      <pubDate>Sat, 01 Apr 2023 14:02:36 -0700</pubDate>
      
      <guid>https://www.lei.chat/posts/single-node-ml-runtime-foundation/</guid>
      <description>&lt;p&gt;Previous blog posts overviewed the MLIR dialect hierarchy for &lt;a href=&#34;../mlir-codegen-dialects-for-machine-learning-compilers/&#34;&gt;kernel code
generation&lt;/a&gt; (CodeGen) and zoomed in on the
&lt;a href=&#34;../mlir-linalg-dialect-and-patterns/&#34;&gt;Linalg&lt;/a&gt; and &lt;a href=&#34;../mlir-vector-dialect-and-patterns/&#34;&gt;Vector&lt;/a&gt; dialects among them.
Now I will switch to discuss the runtime side a bit, in order to provide
a holistic view of MLIR-based machine learning (ML) compilers.
This one touches the foundation and basics, including the target landscape,
runtime requirements and designs to meet thereof.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CodeGen Performant Convolution Kernels for Mobile GPUs</title>
      <link>https://www.lei.chat/posts/codegen-performant-convolution-kernels-for-mobile-gpus/</link>
      <pubDate>Sun, 19 Sep 2021 19:17:07 -0400</pubDate>
      
      <guid>https://www.lei.chat/posts/codegen-performant-convolution-kernels-for-mobile-gpus/</guid>
      <description>&lt;p&gt;This blog post talks about how to generate performant code for convolution ops
using MLIR’s multiple levels of abstractions and transformations.
I initially created it for targeting ARM Mali GPUs in IREE. But given it is
just direct tiling and vectorization, it should be widely applicable.&lt;/p&gt;
&lt;p&gt;I will walk through the lowering steps, so if you are interested to know how to
organize MLIR’s various dialects/patterns together to achieve similar tasks,
this blog post might also be useful.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sampling Performance Counters from Mobile GPU Drivers</title>
      <link>https://www.lei.chat/posts/sampling-performance-counters-from-gpu-drivers/</link>
      <pubDate>Thu, 08 Jul 2021 19:16:41 -0400</pubDate>
      
      <guid>https://www.lei.chat/posts/sampling-performance-counters-from-gpu-drivers/</guid>
      <description>&lt;p&gt;In a &lt;a href=&#34;../android-linux-gpu-drivers-internals-and-resources&#34;&gt;previous blog post&lt;/a&gt; I gave a general introduction
to GPU driver internals in Android/Linux systems. Following up with it, today
I will explain how a specific functionality, hardware performance counter
(perf counter) queries, is handled in both Qualcomm Adreno and ARM Mali drivers,
by walking through the kernel driver source code.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android/Linux GPU Drivers: Internals and Resources</title>
      <link>https://www.lei.chat/posts/android-linux-gpu-drivers-internals-and-resources/</link>
      <pubDate>Mon, 05 Jul 2021 18:20:07 -0400</pubDate>
      
      <guid>https://www.lei.chat/posts/android-linux-gpu-drivers-internals-and-resources/</guid>
      <description>&lt;p&gt;Recently I have been working on a library that needs to directly interact with
GPU kernel drivers from various vendors on Android/Linux systems. Compared to
various GPU APIs, information at this level is quite sparse; so it is not a
straightforward task, to say the least, and ends up requiring me to piece
multiple sources together to figure out the details. So I am logging these driver
internals and resources down in case it can be useful to others that are
interested in these low-level bits.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>What is Vulkan Compute?</title>
      <link>https://www.lei.chat/posts/what-is-vulkan-compute/</link>
      <pubDate>Fri, 25 Jun 2021 10:15:58 -0400</pubDate>
      
      <guid>https://www.lei.chat/posts/what-is-vulkan-compute/</guid>
      <description>&lt;p&gt;Vulkan is designed to be both a graphics and compute API. However, there is no
formal definition of the compute subset from the Khronos group, the industry
consortium behind Vulkan. The unified specification of Vulkan does not help here
either as it contains everything, both graphics and compute. Unlike the
complicated graphics subset, the compute subset is actually quite
straightforward and clean. So in this blog post I try to explain what Vulkan
compute is, from my point of view.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Shader Toolchain: HLSL in Vulkan</title>
      <link>https://www.lei.chat/posts/shader-toolchain-hlsl-in-vulkan/</link>
      <pubDate>Sat, 12 May 2018 17:44:14 -0400</pubDate>
      
      <guid>https://www.lei.chat/posts/shader-toolchain-hlsl-in-vulkan/</guid>
      <description>&lt;p&gt;On &lt;a href=&#34;https://www.khronos.org/events/2018-vulkan-developer-day-in-montreal&#34;&gt;2018 Vulkan Developer Day in Montréal&lt;/a&gt;, I gave a talk
regarding “Shader Toolchain: HLSL in Vulkan”. Here are the links to the
video recording, slides, and documentation/downloads for DirectX Shader
Compiler (DXC) SPIR-V CodeGen.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>HLSL for Vulkan: Semantic Strings and Location Numbers</title>
      <link>https://www.lei.chat/posts/hlsl-for-vulkan-semantic-strings-and-location-numbers/</link>
      <pubDate>Fri, 11 May 2018 13:15:45 -0400</pubDate>
      
      <guid>https://www.lei.chat/posts/hlsl-for-vulkan-semantic-strings-and-location-numbers/</guid>
      <description>&lt;p&gt;This blog post discusses how HLSL semantic strings are translated into
SPIR-V location numbers for Vulkan shader inter-stage interface matching
in the &lt;a href=&#34;https://github.com/Microsoft/DirectXShaderCompiler/blob/master/docs/SPIR-V.rst&#34;&gt;SPIR-V CodeGen&lt;/a&gt; of &lt;a href=&#34;https://github.com/Microsoft/DirectXShaderCompiler&#34;&gt;DirectXShaderCompiler&lt;/a&gt; (DXC).
It is one of the “HLSL for Vulkan” series.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>HLSL for Vulkan: Resources</title>
      <link>https://www.lei.chat/posts/hlsl-for-vulkan-resources/</link>
      <pubDate>Tue, 24 Apr 2018 16:39:21 -0400</pubDate>
      
      <guid>https://www.lei.chat/posts/hlsl-for-vulkan-resources/</guid>
      <description>&lt;p&gt;This blog post discusses how to manage resources in HLSL for Vulkan, using the
&lt;a href=&#34;https://github.com/Microsoft/DirectXShaderCompiler/blob/master/docs/SPIR-V.rst&#34;&gt;SPIR-V CodeGen&lt;/a&gt; of &lt;a href=&#34;https://github.com/Microsoft/DirectXShaderCompiler&#34;&gt;DirectXShaderCompiler&lt;/a&gt; (DXC).
It is one of the “HLSL for Vulkan” series.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>HLSL for Vulkan: Matrices</title>
      <link>https://www.lei.chat/posts/hlsl-for-vulkan-matrices/</link>
      <pubDate>Wed, 18 Apr 2018 20:13:20 -0400</pubDate>
      
      <guid>https://www.lei.chat/posts/hlsl-for-vulkan-matrices/</guid>
      <description>&lt;p&gt;This blog post discusses how HLSL matrices are translated into SPIR-V for Vulkan
consumption in the &lt;a href=&#34;https://github.com/Microsoft/DirectXShaderCompiler/blob/master/docs/SPIR-V.rst&#34;&gt;SPIR-V CodeGen&lt;/a&gt; of &lt;a href=&#34;https://github.com/Microsoft/DirectXShaderCompiler&#34;&gt;DirectXShaderCompiler&lt;/a&gt;.
It is one of the “HLSL for Vulkan” series.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
